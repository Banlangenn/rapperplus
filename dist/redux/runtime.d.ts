declare const _default: "\nimport { IAction, IEnhancerProps, IStore, IRequestParams, StoreEnhancer, StoreCreator, Reducer, AnyAction } from './types'\n\nexport const RAP_REDUX_REQUEST = '$$_RAP_REDUX_REQUEST'\nexport const RAP_REDUX_UPDATE_STORE = '$$_RAP_REDUX_UPDATE_STORE'\nexport const RAP_REDUX_CLEAR_STORE = '$$_RAP_REDUX_CLEAR_STORE'\nexport const RAP_STATE_KEY = '$$rapResponseData'\n\n/** 拼接组合request链接 */\nconst getEndpoint = (requestPrefix: string, url: string): string => {\n    if (!requestPrefix) {\n        requestPrefix = ''\n    }\n    requestPrefix = requestPrefix.replace(/\\/$/, '')\n    url = url.replace(/^\\//, '')\n    return requestPrefix + '/' + url\n}\n\n/**\n * search 参数转换，比如 { a: 1, b: 2, c: undefined } 转换成 \"a=1&b=2\"\n * 会自动删除 undefined\n */\nfunction locationStringify(\n    obj: {\n        [key: string]: any\n    } = {}\n): string {\n    return Object.entries(obj).reduce((str, [key, value]) => {\n        if (value === undefined) {\n            return str\n        }\n        str = str ? str + '&' : str\n        return str + key + '=' + value\n    }, '')\n}\n\nconst sendRequest = async (params: IRequestParams): Promise<any> => {\n    let requestUrl = params.endpoint\n    const requestParams: any = {\n        credentials: 'include',\n        method: params.method || 'GET',\n        headers: { 'Content-Type': 'application/json' },\n    }\n\n    if (requestParams.method === 'GET') {\n        requestUrl = requestUrl + '?' + locationStringify(params.params)\n    } else if (params.params) {\n        requestParams.body = JSON.stringify(params.params)\n    }\n    const res = await fetch(requestUrl, requestParams)\n    const retJSON = res.clone() // clone before return\n    return retJSON.json()\n}\n\nlet dispatch = (action: IAction): Promise<any> => {\n    return new Promise(() => { })\n}\n\ninterface IAssignDataProps {\n    /** 合并前的State */\n    oldState: object\n    /** 最大缓存数 */\n    maxCacheLength?: number\n    payload: {\n        /** 接口的key */\n        interfaceKey: string\n        /** 请求的唯一id，暂时等于requestTime */\n        id: number\n        /** 请求时间，同时也可作为本次请求的key */\n        requestTime: number\n        /** 响应时间 */\n        reponseTime?: number\n        /** 请求参数*/\n        request?: any\n        /** 请求响应数据 */\n        response?: any\n        /** 是否正在 fetching */\n        isFetching: boolean\n    }\n}\ninterface IStateInterfaceItem {\n    id: number\n    requestTime: number\n    request?: any\n    isFetching: boolean\n    reponseTime?: number\n    response?: any\n}\nfunction assignData({\n    oldState,\n    payload: { interfaceKey, id, requestTime, reponseTime, request = {}, response, isFetching },\n    maxCacheLength,\n}: IAssignDataProps) {\n    let newState = { ...oldState }\n    if (typeof maxCacheLength !== 'number' || maxCacheLength < 1) {\n        maxCacheLength = 2\n    }\n\n    let data = newState[interfaceKey] || []\n    if (isFetching === true) {\n        /** 只存最近 maxCacheLength 个数据 */\n        if (maxCacheLength !== Infinity && data.length >= maxCacheLength) {\n            data = newState[interfaceKey].slice(data.length - maxCacheLength + 1)\n        }\n        newState[interfaceKey] = [].concat(data, {\n            id,\n            requestTime,\n            request,\n            isFetching,\n        })\n    } else {\n        newState[interfaceKey] = data.map((item: IStateInterfaceItem) => (item.id === id ? { ...item, reponseTime, response, isFetching } : item))\n    }\n\n    return newState\n}\n\nexport const rapReducers = {\n    [RAP_STATE_KEY]: (state = {}) => state,\n}\n\n/** store enhancer */\nexport function rapEnhancer(config?: IEnhancerProps): StoreEnhancer<any> {\n    config = config || {}\n    const { requestPrefix, transformRequest = data => data, transformResponse = data => data, maxCacheLength = 2, fetch } = config\n\n    const request = typeof fetch === 'function' ? fetch : sendRequest\n\n    return (next: StoreCreator) => <S, A extends AnyAction>(reducers: Reducer<any, any>, ...args: any[]) => {\n        const store = next(reducers, ...args)\n\n        /** 重新定义 reducers */\n        const newReducers = (state: any, action: IAction): IStore => {\n            if (state) {\n                state[RAP_STATE_KEY] || (state[RAP_STATE_KEY] = {})\n            } else {\n                state = { [RAP_STATE_KEY]: {} }\n            }\n\n            if (!action.hasOwnProperty('type')) {\n                return reducers(state, action)\n            }\n\n            switch (action.type) {\n                /** 请求成功，更新 store */\n                case RAP_REDUX_UPDATE_STORE:\n                    return {\n                        ...state,\n                        [RAP_STATE_KEY]: assignData({\n                            oldState: state[RAP_STATE_KEY],\n                            maxCacheLength,\n                            payload: action.payload,\n                        }),\n                    }\n                /** 用户手动清空 */\n                case RAP_REDUX_CLEAR_STORE:\n                    return {\n                        ...state,\n                        [RAP_STATE_KEY]: {\n                            ...state[RAP_STATE_KEY],\n                            ...action.payload,\n                        },\n                    }\n                default:\n                    return reducers(state, action)\n            }\n        }\n        store.replaceReducer(newReducers)\n\n        /** 重新定义 dispatch */\n        dispatch = async (action: IAction): Promise<any> => {\n            if (action.type !== RAP_REDUX_REQUEST) {\n                return store.dispatch(action)\n            }\n\n            const {\n                modelName,\n                endpoint,\n                method,\n                params,\n                cb,\n                types: [REQUEST, SUCCESS, FAILURE],\n            } = action.payload\n            const requestTime = new Date().getTime()\n\n            store.dispatch({ type: REQUEST })\n            store.dispatch({\n                type: RAP_REDUX_UPDATE_STORE,\n                payload: {\n                    interfaceKey: modelName,\n                    id: requestTime,\n                    requestTime,\n                    request: params,\n                    isFetching: true,\n                },\n            })\n            try {\n                /** 请求参数统一处理 */\n                let newParams = params\n                if (typeof transformRequest === 'function') {\n                    newParams = transformRequest(action.payload)\n                }\n\n                const responseData = await request({\n                    endpoint: getEndpoint(requestPrefix, endpoint),\n                    method,\n                    params: newParams,\n                })\n                const reponseTime = new Date().getTime()\n\n                cb && cb(responseData)\n                /** 请求成功，更新store */\n                store.dispatch({\n                    type: RAP_REDUX_UPDATE_STORE,\n                    payload: {\n                        interfaceKey: modelName,\n                        id: requestTime,\n                        requestTime,\n                        reponseTime,\n                        request: params,\n                        response: transformResponse(responseData),\n                        isFetching: false,\n                    },\n                })\n                store.dispatch({ type: SUCCESS, payload: responseData })\n                return responseData\n            } catch (e) {\n                store.dispatch({ type: FAILURE, payload: e })\n                store.dispatch({\n                    type: RAP_REDUX_UPDATE_STORE,\n                    payload: {\n                        interfaceKey: modelName,\n                        id: requestTime,\n                        requestTime,\n                        isFetching: false,\n                    },\n                })\n                throw Error(e)\n            }\n        }\n\n        return { ...store, dispatch }\n    }\n}\n\n/** 发送请求 */\nexport function dispatchAction(action: IAction): Promise<any> {\n    return dispatch(action)\n}\n";
export default _default;
