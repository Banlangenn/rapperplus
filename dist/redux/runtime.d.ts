declare const _default: "\nimport { IAction, IEnhancerProps, IStore, StoreEnhancer, StoreCreator, Reducer, AnyAction } from './types'\nimport baseFetch from './base-fetch'\n\nexport const RAPPER_REQUEST = '$$RAPPER_REQUEST'\nexport const RAPPER_UPDATE_STORE = '$$RAPPER_UPDATE_STORE'\nexport const RAPPER_CLEAR_STORE = '$$RAPPER_CLEAR_STORE'\nexport const RAPPER_STATE_KEY = '$$rapperResponseData'\n\nlet dispatch = <Res>(action: IAction): Promise<AnyAction | Res> => {\n    return new Promise(() => null)\n}\n\n/** redux store存的数据结构 */\ninterface IStateInterfaceItem {\n    /** 请求的唯一id，暂时等于requestTime */\n    id: number\n    /** 请求时间 */\n    requestTime: number\n    /** 请求参数 */\n    request?: any\n    /** 是否正在 fetching */\n    isFetching: boolean\n    /** 响应时间 */\n    reponseTime?: number\n    /** 请求响应数据 */\n    response?: any\n}\ninterface IAssignDataProps {\n    /** 合并前的State */\n    oldState: {\n        [key: string]: IStateInterfaceItem[]\n    }\n    /** 最大缓存数 */\n    maxCacheLength?: number\n    payload: {\n        /** 接口的key */\n        interfaceKey: string\n        id: number\n        requestTime: number\n        reponseTime?: number\n        request?: any\n        response?: any\n        isFetching: boolean\n    }\n}\nfunction assignData({\n    oldState,\n    payload: { interfaceKey, id, requestTime, reponseTime, request = {}, response, isFetching },\n    maxCacheLength,\n}: IAssignDataProps) {\n    const newState = { ...oldState }\n    if (typeof maxCacheLength !== 'number' || maxCacheLength < 1) {\n        maxCacheLength = 2\n    }\n\n    let data = newState[interfaceKey] || []\n    if (isFetching === true) {\n        /** 只存最近 maxCacheLength 个数据 */\n        if (maxCacheLength !== Infinity && data.length >= maxCacheLength) {\n            data = newState[interfaceKey].slice(data.length - maxCacheLength + 1)\n        }\n        newState[interfaceKey] = [...data, { id, requestTime, request, isFetching }]\n    } else {\n        newState[interfaceKey] = data.map((item: IStateInterfaceItem) => (item.id === id ? { ...item, reponseTime, response, isFetching } : item))\n    }\n\n    return newState\n}\n\nexport const rapReducers = {\n    [RAPPER_STATE_KEY]: (state = {}) => state,\n}\n\n/** store enhancer */\nexport function rapEnhancer(config?: IEnhancerProps): StoreEnhancer<any> {\n    config = config || {}\n    const { maxCacheLength = 2 } = config\n\n    return (next: StoreCreator) => (reducers: Reducer<any, any>, ...args: any[]) => {\n        const store = next(reducers, ...args)\n\n        /** 重新定义 reducers */\n        const newReducers = (state: any, action: IAction): IStore => {\n            if (state && !state[RAPPER_STATE_KEY]) {\n                throw Error('rapper初始化配置失败，rootReducer应该加入rapReducers，具体请查看demo配置')\n            }\n\n            if (!action.hasOwnProperty('type')) {\n                return reducers(state, action)\n            }\n\n            switch (action.type) {\n                /** 请求成功，更新 store */\n                case RAPPER_UPDATE_STORE:\n                    return {\n                        ...state,\n                        [RAPPER_STATE_KEY]: assignData({\n                            oldState: state[RAPPER_STATE_KEY],\n                            maxCacheLength,\n                            payload: action.payload,\n                        }),\n                    }\n                /** 用户手动清空 */\n                case RAPPER_CLEAR_STORE:\n                    return {\n                        ...state,\n                        [RAPPER_STATE_KEY]: {\n                            ...state[RAPPER_STATE_KEY],\n                            ...action.payload,\n                        },\n                    }\n                default:\n                    return reducers(state, action)\n            }\n        }\n        store.replaceReducer(newReducers)\n\n        /** 重新定义 dispatch */\n        dispatch = async <Res>(action: IAction): Promise<any> => {\n            if (action.type !== RAPPER_REQUEST) {\n                return store.dispatch(action)\n            }\n\n            const {\n                modelName,\n                url,\n                method,\n                params,\n                cb,\n                types: [REQUEST, SUCCESS, FAILURE],\n            } = action.payload\n            const requestTime = new Date().getTime()\n\n            store.dispatch({ type: REQUEST })\n            store.dispatch({\n                type: RAPPER_UPDATE_STORE,\n                payload: {\n                    interfaceKey: modelName,\n                    id: requestTime,\n                    requestTime,\n                    request: params,\n                    isFetching: true,\n                },\n            })\n            try {\n                const responseData = await baseFetch<Res>({ url, method, params })\n                const reponseTime = new Date().getTime()\n\n                cb && cb(responseData)\n                store.dispatch({ type: SUCCESS, payload: responseData })\n                /** 请求成功，更新store */\n                store.dispatch({\n                    type: RAPPER_UPDATE_STORE,\n                    payload: {\n                        interfaceKey: modelName,\n                        id: requestTime,\n                        requestTime,\n                        reponseTime,\n                        request: params,\n                        response: responseData,\n                        isFetching: false,\n                    },\n                })\n                return responseData\n            } catch (e) {\n                store.dispatch({ type: FAILURE, payload: e })\n                store.dispatch({\n                    type: RAPPER_UPDATE_STORE,\n                    payload: {\n                        interfaceKey: modelName,\n                        id: requestTime,\n                        requestTime,\n                        isFetching: false,\n                    },\n                })\n                throw Error(e)\n            }\n        }\n\n        return { ...store, dispatch }\n    }\n}\n\n/** 发送请求 */\nexport function dispatchAction<Res>(action: AnyAction) {\n    return dispatch<Res>(action)\n}\n";
export default _default;
