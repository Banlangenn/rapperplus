declare const _default: "\n/** 请求类型 */\ntype REQUEST_METHOD = 'GET' | 'POST' | 'PUT' | 'DELETE' | 'OPTIONS' | 'PATCH' | 'HEAD'\n\ninterface Action<T = any> {\n    type: T\n}\nexport interface AnyAction extends Action {\n    [extraProps: string]: any\n}\nexport interface IRequestAction {\n    type: '$$RAPPER_REQUEST'\n    payload?: {\n        modelName: string\n        endpoint: string\n        method?: REQUEST_METHOD\n        params?: any\n        types: string[]\n    }\n}\n\nexport type IAction = AnyAction | IRequestAction\n\n/** store enhancer 参数 */\nexport interface IEnhancerProps {\n    /** 后端api地址，默认是根目录相对路径 */\n    requestPrefix?: string\n    /** 缓存数据最大长度 */\n    maxCacheLength?: number\n}\n\ninterface Dispatch<A = AnyAction> {\n    <T extends A>(action: T, ...extraArgs: any[]): T\n}\ninterface Unsubscribe {\n    (): void\n}\nexport type Reducer<S = any, A = AnyAction> = (state: S | undefined, action: A) => S\ntype ExtendState<State, Extension> = [Extension] extends [never] ? State : State & Extension\ntype Observer<T> = {\n    next?(value: T): void\n}\ntype Observable<T> = {\n    subscribe: (observer: Observer<T>) => { unsubscribe: Unsubscribe }\n    [Symbol.observable](): Observable<T>\n}\n\nexport type StoreEnhancer<Ext = {}, StateExt = {}> = (next: StoreEnhancerStoreCreator) => StoreEnhancerStoreCreator<Ext, StateExt>\n\nexport type StoreEnhancerStoreCreator<Ext = {}, StateExt = {}> = <S = any, A extends Action = AnyAction>(\n    reducer: Reducer<S, A>,\n    preloadedState?: DeepPartial<S>\n) => IStore<S & StateExt, A> & Ext\n\nexport type DeepPartial<T> = {\n    [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K]\n}\n\n/** Store */\nexport interface IStore<S = any, A = IAction, StateExt = never, Ext = {}> {\n    dispatch: Dispatch<A>\n    getState(): S\n    subscribe(listener: () => void): Unsubscribe\n    replaceReducer<NewState, NewActions>(\n        nextReducer: Reducer<NewState, NewActions>\n    ): IStore<ExtendState<NewState, StateExt>, NewActions, StateExt, Ext> & Ext\n    [Symbol.observable](): Observable<S>\n}\n\ndeclare const $CombinedState: unique symbol\n\nexport type CombinedState<S> = { readonly [$CombinedState]?: undefined } & S\n\nexport type PreloadedState<S> = Required<S> extends {\n    [$CombinedState]: undefined\n}\n    ? S extends CombinedState<infer S1>\n    ? {\n        [K in keyof S1]?: S1[K] extends object ? PreloadedState<S1[K]> : S1[K]\n    }\n    : never\n    : {\n        [K in keyof S]: S[K] extends object ? PreloadedState<S[K]> : S[K]\n    }\n\nexport interface StoreCreator {\n    <S, A extends Action, Ext = {}, StateExt = never>(reducer: Reducer<S, A>, enhancer?: StoreEnhancer<Ext, StateExt>): IStore<\n        ExtendState<S, StateExt>,\n        A,\n        StateExt,\n        Ext\n    > &\n        Ext\n    <S, A extends Action, Ext = {}, StateExt = never>(\n        reducer: Reducer<S, A>,\n        preloadedState?: PreloadedState<S>,\n        enhancer?: StoreEnhancer<Ext>\n    ): IStore<ExtendState<S, StateExt>, A, StateExt, Ext> & Ext\n}\n";
export default _default;
